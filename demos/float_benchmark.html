<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Elements</title>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/jsbi@3.1.4/dist/jsbi-umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/decimal.js/9.0.0/decimal.js"></script>

<script id="setup">
  deferLoad()

  var BI = Grapheme.BigInt
  var BF = Grapheme.BigFloat

  function mulberry32(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  function referenceAddMantissas (mant1, mant1Len, mant2, mant2Len, mant2Shift, prec, target, targetLen, round=CURRENT_ROUNDING_MODE) {
    let output = new Int32Array(Math.max(mant1Len, mant2Len + mant2Shift) + 1)

    for (let i = 0; i < mant1Len; ++i) {
      output[i] += mant1[i]
    }

    for (let i = 0; i < mant2Len; ++i) {
      output[i + mant2Shift] += mant2[i]
    }

    let carry = 0
    for (let i = output.length - 1; i >= 0; --i) {
      let word = output[i] + carry

      if (word > 0x3fffffff) {
        word -= 0x40000000
        carry = 1
      } else {
        carry = 0
      }

      output[i] = word
    }

    if (carry === 1) {
      Grapheme.rightShiftMantissa(output, 30, output)
      output[0] = carry
    }

    let roundingShift = Grapheme.roundMantissaToPrecision(output, prec, target, round)
    return carry + roundingShift
  }

  var precision = 100 // decimal digits
  var binaryPrecision = (precision * 3.23) | 0
  Decimal.config({ precision })
  BF.setBinaryPrecision(precision)

  var res
  var floats = generateRandomFloats()
  var boundedFloats = floats.map(f => Math.log2(Math.abs(f)) % 500)

  var bigFloats = floats.map(f => BF.fromNumber(f))
  var decimalFloats = floats.map(f => new Decimal(f.toPrecision(precision)))

  var boundedBigFloats = boundedFloats.map(f => BF.fromNumber(f))
  var boundedDecimalFloats = boundedFloats.map(f => new Decimal(f.toPrecision(precision)))

  function generateRandomFloats() {
    let seed = 6
    let gen = mulberry32(seed)

    var a = new Float64Array(1)
    var view = new BigUint64Array(a.buffer)
    var arr = []

    for (var i = 0; i < 1000; ++i) {
      view[0] = BigInt((gen() * 2 ** 32) >>> 0) + BigInt(gen() * 2 ** 64)
      arr.push(a[0])
    }

    return arr
  }

  function fromNumber() {
    for (let i = 0; i < floats.length; ++i) {
      res = BF.fromNumber(floats[i])
    }
  }

  function toNumber() {
    for (let i = 0; i < floats.length; ++i) {
      res = bigFloats[i].toNumber()
    }
  }

  function addition() {
    res = BF.new(binaryPrecision)

    for (let i = 0; i < floats.length; ++i) {
      for (let j = 0; j < floats.length; ++j) {
        BF.addTo(bigFloats[i], bigFloats[j], res, Grapheme.ROUNDING_MODE.NEAREST)
      }
    }
  }

  function decimalAddition () {
    let res

    for (let i = 0; i < floats.length; ++i) {
      for (let j = 0; j < floats.length; ++j) {
        res = decimalFloats[i].add(decimalFloats[j])
      }
    }
  }

  function multiplication() {
    res = BF.new(binaryPrecision)

    for (let i = 0; i < floats.length; ++i) {
      for (let j = 0; j < floats.length; ++j) {
        BF.mulTo(boundedBigFloats[i], boundedBigFloats[j], res, Grapheme.ROUNDING_MODE.NEAREST)
      }
    }
  }

  function decimalMultiplication () {
    for (let i = 0; i < floats.length; ++i) {
      for (let j = 0; j < floats.length; ++j) {
        res = boundedDecimalFloats[i].mul(boundedDecimalFloats[j])
      }
    }
  }

  function division() {
    res = BF.new(binaryPrecision)

    for (let i = 0; i < floats.length; ++i) {
      for (let j = 0; j < floats.length; ++j) {
        BF.divTo(boundedBigFloats[i], boundedBigFloats[j], res, Grapheme.ROUNDING_MODE.WHATEVER)
      }
    }
  }

  function decimalDivision () {
    for (let i = 0; i < floats.length; ++i) {
      for (let j = 0; j < floats.length; ++j) {
        res = boundedDecimalFloats[i].div(boundedDecimalFloats[j])
      }
    }
  }

  function sqrt () {
    for (let i = 0; i < floats.length; ++i) {
      res = BF.sqrt(boundedBigFloats[i])
    }
  }

  function decimalSqrt () {
    for (let i = 0; i < floats.length; ++i) {
      res = boundedDecimalFloats[i].sqrt()
    }
  }

  function ln() {
    for (let i = 0; i < floats.length; ++i) {
      res = BF.ln(boundedBigFloats[i])
    }
  }

  function decimalLn () {
    for (let i = 0; i < floats.length; ++i) {
      res = boundedDecimalFloats[i].ln()
    }
  }

  function benchmark(callback, name, iterations) {
    setTimeout(() => {
      let timeStart = Date.now()

      for (let i = 0; i < iterations; ++i)
        callback()

      let timeEnd = Date.now()

      document.body.innerHTML += `Benchmark ${name}: ${(timeEnd - timeStart) / iterations} ms per iteration for ${iterations} iterations<br>`
    })
  }

  function blah () {
    benchmark(fromNumber, "fromNumber", 100)
    benchmark(toNumber, "toNumber", 100)
    benchmark(addition, "addition", 300)
    benchmark(multiplication, "multiplication", 10)
  }

  function benchmarkAddition () {
    benchmark(decimalAddition, "decimal.js addition", 10)
    benchmark(addition, "BF addition", 10)
  }

  function benchmarkMultiplication () {
    benchmark(decimalMultiplication, "decimal.js multiplication", 10)
    benchmark(multiplication, "BF multiplication", 10)
  }

  function benchmarkDivision () {
    benchmark(decimalDivision, "decimal.js division", 10)
    benchmark(division, "BF division", 10)
  }

  function benchmarkSqrt () {
    benchmark(decimalSqrt, "decimal.js sqrt", 10)
    benchmark(sqrt, "BF sqrt", 10)
  }

  function benchmarkLn () {
    benchmark(decimalLn, "decimal.js ln", 10)
    benchmark(ln, "BF ln", 10)
  }

  var ln2str = "0.6931471805599453094172321214581765680755001343602552541206800094933936219696947156058633269964186875420014810205706857336855202357581305570326707516350759619307275708283714351903070386238916734711233501153644979552391204751726815749320651555247341395258829504530070953263666426541042391578149520437404303855008019441706416715186447128399681717845469570262716310645461502572074024816377733896385506952606683411372738737229289564935470257626520988596932019650585547647033067936544325476327449512504060694381471046899465062201677204245245296126879465461931651746813926725041038025462596568691441928716082938031727143677826548775664850856740776484514644399404614226031930967354025744460703080960850474866385231381816767514386674766478908814371419854942315199735488037516586127535291661000710535582498794147295092931138971559982056543928717000721808576102523688921324497138932037843935308877482597017155910708823683627589842589185353024363421436706118923678919237231467232172053401649256872747782344535348"

  //var ln2 = BF.ln(2, 200)

  var target = new Int32Array(2)
  var cow = 0, cow2 = 0

  Decimal.precision = 1000;
  /**
   Before moving primitive functions to C-like writing instead of returning value
   Benchmark fromNumber: 0.158 ms per iteration for 1000 iterations
   Benchmark toNumber: 1.4 ms per iteration for 10 iterations
   Benchmark addition: 385 ms per iteration for 2 iterations
   Benchmark multiplication: 466.5 ms per iteration for 2 iterations
   Benchmark division: 4340 ms per iteration for 2 iterations
   */

  /**
   * As of Sep 18
   Benchmark decimal.js addition: 735 ms per iteration for 10 iterations
   Benchmark BF addition: 166.9 ms per iteration for 10 iterations
   Benchmark decimal.js multiplication: 1083.2 ms per iteration for 10 iterations
   Benchmark BF multiplication: 271.4 ms per iteration for 10 iterations
   Benchmark decimal.js sqrt: 1696.1 ms per iteration for 10 iterations
   Benchmark BF sqrt: 11.2 ms per iteration for 10 iterations
   Benchmark decimal.js division: 50133 ms per iteration for 10 iterations
   Benchmark BF division: 13065.6 ms per iteration for 10 iterations
   */
</script>

<script src="test_setup.js"></script>


</body>
</html>
