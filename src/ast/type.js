import { getAngryAt } from './parser_error'

const matchType = /^[a-zA-Z_][a-zA-Z_0-9]*/

function checkAngleBracketsBalanced (string, onParserError) {
  const stack = []

  let i = 0

  for (; i < string.length; ++i) {
    let char = string[i]

    switch (char) {
      case '<':
        stack.push('<')
        break
      case '>':
        const last = stack.pop()

        if (last === '<') {
          break
        }

        onParserError(string, i, 'Unbalanced angle brackets in type definition')
        return
    }
  }

  if (stack.length !== 0) {
    onParserError(string, i, 'Unbalanced angle brackets in type definition')
  }
}

const tokenizerStrings = ['<', '>', '::', ',']

function * typeTokenizer (string, onParserError = getAngryAt) {
  checkAngleBracketsBalanced(string, onParserError)

  string = string.trimEnd()

  let i = 0
  let prevLen = string.length

  const originalString = string

  outerLoop:
    while (string) {
      string = string.trim()

      i += prevLen - string.length
      prevLen = string.length

      for (const token of tokenizerStrings) {
        if (string.startsWith(token)) {
          yield {
            type: token,
            index: i
          }

          string = string.slice(token.length)

          continue outerLoop
        }
      }

      // If none of those tokens were matched, we either have a type or an invalid token

      const match = matchType.exec(string)

      if (match) {
        yield {
          type: 'type',
          index: i,
          str: match[0]
        }
      } else {
        onParserError(originalString, i, 'Unrecognized token')
        return
      }

      string = string.slice(match[0].length)
    }
}

/**
 * Type abstracts a specific type in Grapheme. A type may just be something simple like Type("int"), Type("complex"), etc.,
 * or include template definitions like Type("list::<int>"), Type("pair::<int, complex>"), ...
 */
class Type {
  constructor (str, children=[]) {
    this.str = str

    if (children !== null && !Array.isArray(children))
      throw new TypeError("children must either be null or an array")

    this.children = children
  }

  applyAll(callback) {
    callback(this)

    if (this.children) {
      this.children.forEach(child => child.applyAll(callback))
    }
  }

  static fromString(string, onParserError=getAngryAt) {
    return parseType(string, onParserError)
  }

  static toType(obj) {
    if (obj instanceof Type) {
      return obj
    } else if (typeof obj === "string") {
      return Type.fromString(obj)
    } else {
      throw new Error("Object is not convertible to a Type")
    }
  }

  clone() {
    return new Type(this.str, this.children ? this.children : this.children.map(child => child.clone()))
  }

  argCount() {
    return this.children ? this.children.length : 0
  }

  equals(type) {
    if (type.str !== this.str || this.argCount() !== type.argCount())
      return false

    return this.children.every((child, i) => child.equals())
  }

  hasChildren() {
    return this.children && this.children.length !== 0
  }

  toString() {
    let ret = this.str

    if (this.hasChildren()) {
      ret += "::<" + this.children.map(child => child.toString()).join(", ") + '>'
    }

    return ret
  }

  /**
   * Replace empty arrays in children with
   * @private
   */
  _replaceEmptyChildrenWithNull() {
    this.applyAll(child => {
      if (!child.hasChildren()) {
        child.children = null
      }
    })
  }
}

function parseType (string, onParserError) {
  return parseTypeFromTokens(Array.from(typeTokenizer(string, onParserError)), string, onParserError)
}

const signifiersOfTemplatelessType = ['>', ',']

/**
 * Convert a tokenized type into an actual Type object.
 * @param tokens {Array} List of tokens, generated by typeTokenizer
 * @param originalString {String} The original string to be parsed, used for informative error messages
 * @param onParserError {Function} callback if an error is encountered
 */
function parseTypeFromTokens (tokens, originalString, onParserError) {
  // This happens when there's an error in typeTokenizer, so just return since onParserError was already called
  if (!tokens)
    return null

  const constructionStack = []
  const overallType = tokens[0].str

  if (!overallType) {
    onParserError(originalString, tokens[0].index, "First token must be a type")
  }

  // If the type is just a simple string, return it
  if (tokens.length === 1)
    return new Type(overallType, null)

  let current = new Type(overallType)
  const ret = current

  const lastToken = tokens[tokens.length - 1]

  if (lastToken.type !== '>') {
    onParserError(originalString, lastToken.index, "Last token of a template must be >")
  }

  let currentReadyForSpecialization = false

  constructionStack.push(current)

  function peek() {
    return constructionStack[constructionStack.length - 1]
  }

  for (let i = 1; i < tokens.length; ++i) {
    const token = tokens[i]

    if (token.type === "::") {
      if (currentReadyForSpecialization) {
        onParserError(originalString, token.index, "Successive ::")
        return null
      }

      currentReadyForSpecialization = true
      const nextToken = tokens[i+1]

      if (nextToken.type !== '<') {
        onParserError(originalString, token.index, ":: must always be followed by <")
        return null
      }

    } else if (token.type === "<") {
      if (!currentReadyForSpecialization) {
        onParserError(originalString, token.index, "Starting angle bracket immediately after type name; probably missing ::")
        return null
      }

      currentReadyForSpecialization = false
    } else if (token.type === ">") {
      constructionStack.pop()

      current = peek()
    } else if (token.type === "type") {
      const type = new Type(token.str, [])
      const nextToken = tokens[i+1]

      if (nextToken) {
        peek().children.push(type)

        if (!signifiersOfTemplatelessType.includes(nextToken.type)) {
          current = type
          constructionStack.push(current)


          currentReadyForSpecialization = false
        }
      }
    }
  }

  ret._replaceEmptyChildrenWithNull()

  return ret
}

export { Type }
