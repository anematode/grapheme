import { SingleVariablePolynomial } from './polynomial'

// Credit to https://stackoverflow.com/questions/15454183/how-to-make-a-function-that-computes-the-factorial-for-numbers-with-decimals!! Thank you so much

var g = 7
var LANCZOS_COEFFICIENTS = [
  0.99999999999980993,
  676.5203681218851,
  -1259.1392167224028,
  771.32342877765313,
  -176.61502916214059,
  12.507343278686905,
  -0.13857109526572012,
  9.9843695780195716e-6,
  1.5056327351493116e-7
]
var INTEGER_FACTORIALS = [
  1,
  1,
  2,
  6,
  24,
  120,
  720,
  5040,
  40320,
  362880,
  3628800,
  39916800,
  479001600,
  6227020800,
  87178291200,
  1307674368000,
  20922789888000,
  355687428096000,
  6402373705728000,
  121645100408832000,
  2432902008176640000,
  51090942171709440000,
  1.1240007277776077e+21,
  2.585201673888498e+22,
  6.204484017332394e+23,
  1.5511210043330986e+25,
  4.0329146112660565e+26,
  1.0888869450418352e+28,
  3.0488834461171384e+29,
  8.841761993739701e+30,
  2.6525285981219103e+32,
  8.222838654177922e+33,
  2.631308369336935e+35,
  8.683317618811886e+36,
  2.9523279903960412e+38,
  1.0333147966386144e+40,
  3.719933267899012e+41,
  1.3763753091226343e+43,
  5.23022617466601e+44,
  2.0397882081197442e+46,
  8.159152832478977e+47,
  3.3452526613163803e+49,
  1.4050061177528798e+51,
  6.041526306337383e+52,
  2.6582715747884485e+54,
  1.1962222086548019e+56,
  5.5026221598120885e+57,
  2.5862324151116818e+59,
  1.2413915592536073e+61,
  6.082818640342675e+62,
  3.0414093201713376e+64,
  1.5511187532873822e+66,
  8.065817517094388e+67,
  4.2748832840600255e+69,
  2.308436973392414e+71,
  1.2696403353658276e+73,
  7.109985878048635e+74,
  4.052691950487722e+76,
  2.350561331282879e+78,
  1.3868311854568986e+80,
  8.320987112741392e+81,
  5.075802138772248e+83,
  3.146997326038794e+85,
  1.98260831540444e+87,
  1.2688693218588417e+89,
  8.247650592082472e+90,
  5.443449390774431e+92,
  3.647111091818868e+94,
  2.4800355424368305e+96,
  1.711224524281413e+98,
  1.197857166996989e+100,
  8.504785885678622e+101,
  6.123445837688608e+103,
  4.4701154615126834e+105,
  3.3078854415193856e+107,
  2.480914081139539e+109,
  1.8854947016660498e+111,
  1.4518309202828584e+113,
  1.1324281178206295e+115,
  8.946182130782973e+116,
  7.156945704626378e+118,
  5.797126020747366e+120,
  4.75364333701284e+122,
  3.945523969720657e+124,
  3.314240134565352e+126,
  2.8171041143805494e+128,
  2.4227095383672724e+130,
  2.107757298379527e+132,
  1.8548264225739836e+134,
  1.6507955160908452e+136,
  1.4857159644817607e+138,
  1.3520015276784023e+140,
  1.24384140546413e+142,
  1.1567725070816409e+144,
  1.0873661566567424e+146,
  1.0329978488239052e+148,
  9.916779348709491e+149,
  9.619275968248206e+151,
  9.426890448883242e+153,
  9.33262154439441e+155,
  9.33262154439441e+157,
  9.425947759838354e+159,
  9.614466715035121e+161,
  9.902900716486175e+163,
  1.0299016745145622e+166,
  1.0813967582402903e+168,
  1.1462805637347078e+170,
  1.2265202031961373e+172,
  1.3246418194518284e+174,
  1.4438595832024928e+176,
  1.5882455415227421e+178,
  1.7629525510902437e+180,
  1.9745068572210728e+182,
  2.2311927486598123e+184,
  2.543559733472186e+186,
  2.925093693493014e+188,
  3.3931086844518965e+190,
  3.969937160808719e+192,
  4.6845258497542883e+194,
  5.574585761207603e+196,
  6.689502913449124e+198,
  8.09429852527344e+200,
  9.875044200833598e+202,
  1.2146304367025325e+205,
  1.5061417415111404e+207,
  1.8826771768889254e+209,
  2.372173242880046e+211,
  3.012660018457658e+213,
  3.8562048236258025e+215,
  4.9745042224772855e+217,
  6.466855489220472e+219,
  8.471580690878817e+221,
  1.118248651196004e+224,
  1.4872707060906852e+226,
  1.992942746161518e+228,
  2.6904727073180495e+230,
  3.659042881952547e+232,
  5.01288874827499e+234,
  6.917786472619486e+236,
  9.615723196941086e+238,
  1.346201247571752e+241,
  1.89814375907617e+243,
  2.6953641378881614e+245,
  3.8543707171800706e+247,
  5.550293832739301e+249,
  8.047926057471987e+251,
  1.17499720439091e+254,
  1.7272458904546376e+256,
  2.5563239178728637e+258,
  3.808922637630567e+260,
  5.7133839564458505e+262,
  8.627209774233235e+264,
  1.3113358856834518e+267,
  2.006343905095681e+269,
  3.089769613847349e+271,
  4.789142901463391e+273,
  7.47106292628289e+275,
  1.1729568794264138e+278,
  1.8532718694937338e+280,
  2.946702272495037e+282,
  4.714723635992059e+284,
  7.590705053947215e+286,
  1.2296942187394488e+289,
  2.0044015765453015e+291,
  3.2872185855342945e+293,
  5.423910666131586e+295,
  9.003691705778433e+297,
  1.5036165148649983e+300,
  2.526075744973197e+302,
  4.2690680090047027e+304,
  7.257415615307994e+306
]

function gamma (z) {

  // Define gamma specially for integral values
  if (z % 1 === 0) {
    if (z <= 0) {
      return Infinity
    }

    let res = INTEGER_FACTORIALS[Math.round(z - 1)]

    if (!res) {
      return Infinity
    }

    return res
  }

  if (z < 0.5) {
    return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z))
  } else {
    z -= 1

    var x = LANCZOS_COEFFICIENTS[0]
    for (var i = 1; i < g + 2; i++) {
      x += LANCZOS_COEFFICIENTS[i] / (z + i)
    }

    var t = z + g + 0.5
    return Math.sqrt(2 * Math.PI) * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x
  }
}

function ln_gamma (z) {
  if (z < 0.5) {
    // Compute via reflection formula
    let reflected = ln_gamma(1 - z)

    return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - reflected
  } else {
    z -= 1

    var x = LANCZOS_COEFFICIENTS[0]
    for (var i = 1; i < g + 2; i++) {
      x += LANCZOS_COEFFICIENTS[i] / (z + i)
    }

    var t = z + g + 0.5

    return Math.log(2 * Math.PI) / 2 + Math.log(t) * (z + 0.5) - t + Math.log(x)
  }
}

function polygamma (m, z) {
  if (m % 1 !== 0 || m < 0) {
    return NaN
  }

  if (m === 0) {
    return digamma(z)
  }

  if (m === 1) {
    return trigamma(z)
  }

  let sign = (m % 2 === 0) ? -1 : 1
  let numPoly = getPolygammaNumeratorPolynomial(m)

  if (z < 0.5) {
    if (z % 1 === 0)
      return Infinity

    // Reflection formula, see https://en.wikipedia.org/wiki/Polygamma_function#Reflection_relation
    // psi_m(z) = pi ^ (m+1) * numPoly(cos(pi z)) / (sin ^ (m+1) (pi z)) + (-1)^(m+1) psi_m(1-z)

    return -(Math.pow(Math.PI, m + 1) * numPoly.evaluate(Math.cos(Math.PI * z)) /
      (Math.pow(Math.sin(Math.PI * z), m+1)) + sign * polygamma(m, 1 - z))
  } else if (z < 8) {
    // Recurrence relation
    // psi_m(z) = psi_m(z+1) + (-1)^(m+1) * m! / z^(m+1)

    return polygamma(m, z+1) + sign * gamma(m + 1) / Math.pow(z, m+1)
  }

  // Series representation

  let sum = 0
  for (let i = 0; i < 200; ++i) {
    sum += 1 / Math.pow(z + i, m + 1)
  }

  return sign * gamma(m + 1) * sum

}

const GREGORY_COEFFICIENTS = [
  1.0, 0.5, -0.08333333333333333, 0.041666666666666664, -0.02638888888888889, 0.01875, -0.014269179894179895, 0.01136739417989418, -0.00935653659611993, 0.00789255401234568, -0.006785849984634707, 0.005924056412337663, -0.005236693257950285, 0.004677498407042265, -0.004214952239005473, 0.003826899553211884, -0.0034973498453499175, 0.0032144964313235674, -0.0029694477154582097, 0.002755390299436716, -0.0025670225450072377, 0.0024001623785907204, -0.0022514701977588703, 0.0021182495272954456, -0.001998301255043453, 0.0018898154636786972, -0.0017912900780718936, 0.0017014689263700736, -0.0016192940490963672, 0.0015438685969283421, -0.0014744276890609623, 0.001410315320613454, -0.0013509659123128112, 0.0012958894558251668, -0.0012446594681088444, 0.0011969031579517945, -0.001152293347825886, 0.0011105417984181721, -0.001071393661516785, 0.0010346228462800521, -0.0010000281292566525, 0.0009674298734228264, -0.0009366672485567989, 0.0009075958663860963, -0.0008800857605298948, 0.000854019654366952, -0.0008292914703794421, 0.0008058050428513827, -0.0007834730024921167, 0.0007622158069590723, -0.0007419608956386516, 0.0007226419506180641, -0.0007041982487069233, 0.000686574091772996, -0.0006697183046421545, 0.0006535837914580035, -0.0006381271427651654, 0.0006233082867224927, -0.0006090901788092055, 0.0005954385251909118, -0.0005823215355902033, 0.0005697097020796109, -0.0005575756007007343, 0.0005458937132267388, -0.0005346402667379662, 0.0005237930889818988, -0.0005133314777471911, 0.0005032360827036401, -0.0004934887983513816, 0.00048407266688788627, -0.00047497178994440343, 0.00046617124826760925, -0.00045765702853009814, 0.00044941595654733894, -0.0004414356362607454, 0.0004337043939182513, -0.00042621122694664064, 0.00041894575706506086, -0.0004118981872376783, 0.0004050592621061756, -0.00039842023158052236, 0.0003919728172997837, -0.0003857091817042604, 0.00037962189948642086, -0.00037370393121133474, 0.0003679485989179907, -0.0003623495635312948, 0.0003569008039309683, -0.0003515965975382364, 0.0003464315022943173, -0.00034140033991647036, 0.0003364981803279027, -0.00033172032716728803, 0.00032706230429215997, -0.0003225198431980953, 0.000318088871282497, -0.000313765500888013, 0.00030954601906624203, -0.0003054268780074607, 0.00030140468608670396, -0.00029747619948069663, 0.0002936383143139141
]

let PolygammaNumeratorPolynomials = [new SingleVariablePolynomial([0, 1])]

let POLY1 = new SingleVariablePolynomial([0, 1])
let POLY2 = new SingleVariablePolynomial([-1, 0, 1])

function getPolygammaNumeratorPolynomial(n) {
  let poly = PolygammaNumeratorPolynomials[n]
  if (poly)
    return poly

  if (n > 10000)
    return new SingleVariablePolynomial([0])

  if (n > 20) {
    // to prevent stack overflow issues
    for (let i = 0; i < n; ++i) {
      getPolygammaNumeratorPolynomial(i)
    }
  }

  return PolygammaNumeratorPolynomials[n] =
    getPolygammaNumeratorPolynomial(n - 1).clone().multiplyScalar(-n).multiply(POLY1).add(
      getPolygammaNumeratorPolynomial(n - 1).derivative().multiply(POLY2)
    )
}

function digamma (z) {
  if (z < 0.5) {
    // psi(1-x) - psi(x) = pi cot(pi x)
    // psi(x) = psi(1-x) - pi cot (pi x)

    return digamma(1 - z) - Math.PI / Math.tan(Math.PI * z)
  } else if (z < 15) {
    // psi(x+1) = psi(x) + 1/x
    // psi(x) = psi(x+1) - 1/x

    let sum = 0

    while (z < 15) {
      sum += 1 / z

      z += 1
    }

    return digamma(z) - sum
  }

  let egg = 1
  let sum = Math.log(z)

  for (let n = 1; n < 15; ++n) {
    let coeff = Math.abs(GREGORY_COEFFICIENTS[n])

    egg *= ((n-1) ? (n-1) : 1)
    egg /= z + n - 1

    sum -= coeff * egg
  }

  return sum
}

function trigamma(z) {
  if (z < 0.5) {
    if (z % 1 === 0) {
      return Infinity
    }

    // psi_1(1-z) + psi_1(z) = pi^2 / (sin^2 pi z)
    // psi_1(z) = pi^2 / (sin^2 pi z) - psi_1(1-z)

    return (Math.PI * Math.PI) / (Math.sin(Math.PI * z) ** 2) - trigamma(1-z)
  } else if (z < 20) {
    // psi_1(z+1) = psi_1(z) - 1/z^2
    // psi_1(z) = psi_1(z+1) + 1/z^2

    let sum = 0

    while (z < 20) {
      sum += 1 / (z * z)

      z += 1
    }

    return trigamma(z) + sum
  }

  return 1 / z + 1 / (2 * z**2) + 1 / (6 * z**3) - 1 / (30 * z**5) + 1/(42 * z**7) - 1/(30 * z**9) + 5/(66 * z**11) - 691 / (2730 * z**13) + 7 / (6 * z**15)
}

function factorial(z) {
  return gamma(z + 1)
}

export { gamma, polygamma, ln_gamma, digamma, trigamma, getPolygammaNumeratorPolynomial, GREGORY_COEFFICIENTS, LANCZOS_COEFFICIENTS, INTEGER_FACTORIALS, factorial }
